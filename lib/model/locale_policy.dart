// Copyright 2022 Giammarco Boscaro. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

//
// AUTO-GENERATED FILE, DO NOT MODIFY!
//
// @dart=2.17

// ignore_for_file: unused_element, unused_import
// ignore_for_file: always_put_required_named_parameters_first
// ignore_for_file: constant_identifier_names
// ignore_for_file: lines_longer_than_80_chars

part of it.docusign.sdk.esignature;

class LocalePolicy {
  /// Returns a new [LocalePolicy] instance.
  LocalePolicy({
    this.addressFormat,
    this.addressFormatMetadata,
    this.allowRegion,
    this.calendarType,
    this.calendarTypeMetadata,
    this.cultureName,
    this.cultureNameMetadata,
    this.currencyCode,
    this.currencyCodeMetadata,
    this.currencyNegativeFormat,
    this.currencyNegativeFormatMetadata,
    this.currencyPositiveFormat,
    this.currencyPositiveFormatMetadata,
    this.customDateFormat,
    this.customSignDateFormat,
    this.customSignTimeFormat,
    this.customTimeFormat,
    this.dateFormat,
    this.dateFormatMetadata,
    this.effectiveAddressFormat,
    this.effectiveCalendarType,
    this.effectiveCurrencyCode,
    this.effectiveCurrencyNegativeFormat,
    this.effectiveCurrencyPositiveFormat,
    this.effectiveCustomDateFormat,
    this.effectiveCustomTimeFormat,
    this.effectiveDateFormat,
    this.effectiveInitialFormat,
    this.effectiveNameFormat,
    this.effectiveTimeFormat,
    this.effectiveTimeZone,
    this.initialFormat,
    this.initialFormatMetadata,
    this.nameFormat,
    this.nameFormatMetadata,
    this.signDateFormat,
    this.signDateFormatMetadata,
    this.signTimeFormat,
    this.signTimeFormatMetadata,
    this.timeFormat,
    this.timeFormatMetadata,
    this.timeZone,
    this.timeZoneMetadata,
  });

  /// 
  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  String? addressFormat;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  SettingsMetadata? addressFormatMetadata;

  /// 
  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  String? allowRegion;

  /// 
  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  String? calendarType;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  SettingsMetadata? calendarTypeMetadata;

  /// 
  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  String? cultureName;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  SettingsMetadata? cultureNameMetadata;

  /// The currency code for the account, based on the [ISO 4217 currency code](https://www.iso.org/iso-4217-currency-codes.html).
  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  String? currencyCode;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  SettingsMetadata? currencyCodeMetadata;

  /// 
  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  String? currencyNegativeFormat;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  SettingsMetadata? currencyNegativeFormatMetadata;

  /// 
  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  String? currencyPositiveFormat;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  SettingsMetadata? currencyPositiveFormatMetadata;

  /// 
  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  String? customDateFormat;

  /// 
  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  String? customSignDateFormat;

  /// 
  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  String? customSignTimeFormat;

  /// 
  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  String? customTimeFormat;

  /// 
  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  String? dateFormat;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  SettingsMetadata? dateFormatMetadata;

  /// 
  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  String? effectiveAddressFormat;

  /// 
  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  String? effectiveCalendarType;

  /// 
  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  String? effectiveCurrencyCode;

  /// 
  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  String? effectiveCurrencyNegativeFormat;

  /// 
  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  String? effectiveCurrencyPositiveFormat;

  /// 
  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  String? effectiveCustomDateFormat;

  /// 
  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  String? effectiveCustomTimeFormat;

  /// 
  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  String? effectiveDateFormat;

  /// 
  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  String? effectiveInitialFormat;

  /// 
  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  String? effectiveNameFormat;

  /// 
  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  String? effectiveTimeFormat;

  /// 
  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  String? effectiveTimeZone;

  /// 
  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  String? initialFormat;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  SettingsMetadata? initialFormatMetadata;

  /// 
  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  String? nameFormat;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  SettingsMetadata? nameFormatMetadata;

  /// The format for the signature date. Valid values are:  - `d/M/yyyy` - `dd-MM-yy` - `dd-MMM-yy` - `dd-MM-yyyy` - `dd.MM.yyyy` - `dd-MMM-yyyy` - `dd MMMM yyyy` - `M/d/yyyy` - `MM-dd-yyyy` - `MM/dd/yyyy` - `MM/dd/yy` - `MMM-dd-yyyy` - `MMM d, yyyy` - `MMMM d, yyyy` - `yyyy-MM-dd` - `yyyy-MMM-dd` - `yyyy/MM/dd` - `yyyy MMMM d`  **Note:** Only Admin users can change this setting. 
  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  String? signDateFormat;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  SettingsMetadata? signDateFormatMetadata;

  /// The format for the signature time. Valid values are:  - `none` - `HH:mm` - `h:mm` - `HH:mm:ss` - `h:mm:ss` 
  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  String? signTimeFormat;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  SettingsMetadata? signTimeFormatMetadata;

  /// 
  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  String? timeFormat;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  SettingsMetadata? timeFormatMetadata;

  /// 
  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  String? timeZone;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  SettingsMetadata? timeZoneMetadata;

  @override
  bool operator ==(Object other) => identical(this, other) || other is LocalePolicy &&
     other.addressFormat == addressFormat &&
     other.addressFormatMetadata == addressFormatMetadata &&
     other.allowRegion == allowRegion &&
     other.calendarType == calendarType &&
     other.calendarTypeMetadata == calendarTypeMetadata &&
     other.cultureName == cultureName &&
     other.cultureNameMetadata == cultureNameMetadata &&
     other.currencyCode == currencyCode &&
     other.currencyCodeMetadata == currencyCodeMetadata &&
     other.currencyNegativeFormat == currencyNegativeFormat &&
     other.currencyNegativeFormatMetadata == currencyNegativeFormatMetadata &&
     other.currencyPositiveFormat == currencyPositiveFormat &&
     other.currencyPositiveFormatMetadata == currencyPositiveFormatMetadata &&
     other.customDateFormat == customDateFormat &&
     other.customSignDateFormat == customSignDateFormat &&
     other.customSignTimeFormat == customSignTimeFormat &&
     other.customTimeFormat == customTimeFormat &&
     other.dateFormat == dateFormat &&
     other.dateFormatMetadata == dateFormatMetadata &&
     other.effectiveAddressFormat == effectiveAddressFormat &&
     other.effectiveCalendarType == effectiveCalendarType &&
     other.effectiveCurrencyCode == effectiveCurrencyCode &&
     other.effectiveCurrencyNegativeFormat == effectiveCurrencyNegativeFormat &&
     other.effectiveCurrencyPositiveFormat == effectiveCurrencyPositiveFormat &&
     other.effectiveCustomDateFormat == effectiveCustomDateFormat &&
     other.effectiveCustomTimeFormat == effectiveCustomTimeFormat &&
     other.effectiveDateFormat == effectiveDateFormat &&
     other.effectiveInitialFormat == effectiveInitialFormat &&
     other.effectiveNameFormat == effectiveNameFormat &&
     other.effectiveTimeFormat == effectiveTimeFormat &&
     other.effectiveTimeZone == effectiveTimeZone &&
     other.initialFormat == initialFormat &&
     other.initialFormatMetadata == initialFormatMetadata &&
     other.nameFormat == nameFormat &&
     other.nameFormatMetadata == nameFormatMetadata &&
     other.signDateFormat == signDateFormat &&
     other.signDateFormatMetadata == signDateFormatMetadata &&
     other.signTimeFormat == signTimeFormat &&
     other.signTimeFormatMetadata == signTimeFormatMetadata &&
     other.timeFormat == timeFormat &&
     other.timeFormatMetadata == timeFormatMetadata &&
     other.timeZone == timeZone &&
     other.timeZoneMetadata == timeZoneMetadata;

  @override
  int get hashCode =>
    // ignore: unnecessary_parenthesis
    (addressFormat == null ? 0 : addressFormat!.hashCode) +
    (addressFormatMetadata == null ? 0 : addressFormatMetadata!.hashCode) +
    (allowRegion == null ? 0 : allowRegion!.hashCode) +
    (calendarType == null ? 0 : calendarType!.hashCode) +
    (calendarTypeMetadata == null ? 0 : calendarTypeMetadata!.hashCode) +
    (cultureName == null ? 0 : cultureName!.hashCode) +
    (cultureNameMetadata == null ? 0 : cultureNameMetadata!.hashCode) +
    (currencyCode == null ? 0 : currencyCode!.hashCode) +
    (currencyCodeMetadata == null ? 0 : currencyCodeMetadata!.hashCode) +
    (currencyNegativeFormat == null ? 0 : currencyNegativeFormat!.hashCode) +
    (currencyNegativeFormatMetadata == null ? 0 : currencyNegativeFormatMetadata!.hashCode) +
    (currencyPositiveFormat == null ? 0 : currencyPositiveFormat!.hashCode) +
    (currencyPositiveFormatMetadata == null ? 0 : currencyPositiveFormatMetadata!.hashCode) +
    (customDateFormat == null ? 0 : customDateFormat!.hashCode) +
    (customSignDateFormat == null ? 0 : customSignDateFormat!.hashCode) +
    (customSignTimeFormat == null ? 0 : customSignTimeFormat!.hashCode) +
    (customTimeFormat == null ? 0 : customTimeFormat!.hashCode) +
    (dateFormat == null ? 0 : dateFormat!.hashCode) +
    (dateFormatMetadata == null ? 0 : dateFormatMetadata!.hashCode) +
    (effectiveAddressFormat == null ? 0 : effectiveAddressFormat!.hashCode) +
    (effectiveCalendarType == null ? 0 : effectiveCalendarType!.hashCode) +
    (effectiveCurrencyCode == null ? 0 : effectiveCurrencyCode!.hashCode) +
    (effectiveCurrencyNegativeFormat == null ? 0 : effectiveCurrencyNegativeFormat!.hashCode) +
    (effectiveCurrencyPositiveFormat == null ? 0 : effectiveCurrencyPositiveFormat!.hashCode) +
    (effectiveCustomDateFormat == null ? 0 : effectiveCustomDateFormat!.hashCode) +
    (effectiveCustomTimeFormat == null ? 0 : effectiveCustomTimeFormat!.hashCode) +
    (effectiveDateFormat == null ? 0 : effectiveDateFormat!.hashCode) +
    (effectiveInitialFormat == null ? 0 : effectiveInitialFormat!.hashCode) +
    (effectiveNameFormat == null ? 0 : effectiveNameFormat!.hashCode) +
    (effectiveTimeFormat == null ? 0 : effectiveTimeFormat!.hashCode) +
    (effectiveTimeZone == null ? 0 : effectiveTimeZone!.hashCode) +
    (initialFormat == null ? 0 : initialFormat!.hashCode) +
    (initialFormatMetadata == null ? 0 : initialFormatMetadata!.hashCode) +
    (nameFormat == null ? 0 : nameFormat!.hashCode) +
    (nameFormatMetadata == null ? 0 : nameFormatMetadata!.hashCode) +
    (signDateFormat == null ? 0 : signDateFormat!.hashCode) +
    (signDateFormatMetadata == null ? 0 : signDateFormatMetadata!.hashCode) +
    (signTimeFormat == null ? 0 : signTimeFormat!.hashCode) +
    (signTimeFormatMetadata == null ? 0 : signTimeFormatMetadata!.hashCode) +
    (timeFormat == null ? 0 : timeFormat!.hashCode) +
    (timeFormatMetadata == null ? 0 : timeFormatMetadata!.hashCode) +
    (timeZone == null ? 0 : timeZone!.hashCode) +
    (timeZoneMetadata == null ? 0 : timeZoneMetadata!.hashCode);

  @override
  String toString() => 'LocalePolicy[addressFormat=$addressFormat, addressFormatMetadata=$addressFormatMetadata, allowRegion=$allowRegion, calendarType=$calendarType, calendarTypeMetadata=$calendarTypeMetadata, cultureName=$cultureName, cultureNameMetadata=$cultureNameMetadata, currencyCode=$currencyCode, currencyCodeMetadata=$currencyCodeMetadata, currencyNegativeFormat=$currencyNegativeFormat, currencyNegativeFormatMetadata=$currencyNegativeFormatMetadata, currencyPositiveFormat=$currencyPositiveFormat, currencyPositiveFormatMetadata=$currencyPositiveFormatMetadata, customDateFormat=$customDateFormat, customSignDateFormat=$customSignDateFormat, customSignTimeFormat=$customSignTimeFormat, customTimeFormat=$customTimeFormat, dateFormat=$dateFormat, dateFormatMetadata=$dateFormatMetadata, effectiveAddressFormat=$effectiveAddressFormat, effectiveCalendarType=$effectiveCalendarType, effectiveCurrencyCode=$effectiveCurrencyCode, effectiveCurrencyNegativeFormat=$effectiveCurrencyNegativeFormat, effectiveCurrencyPositiveFormat=$effectiveCurrencyPositiveFormat, effectiveCustomDateFormat=$effectiveCustomDateFormat, effectiveCustomTimeFormat=$effectiveCustomTimeFormat, effectiveDateFormat=$effectiveDateFormat, effectiveInitialFormat=$effectiveInitialFormat, effectiveNameFormat=$effectiveNameFormat, effectiveTimeFormat=$effectiveTimeFormat, effectiveTimeZone=$effectiveTimeZone, initialFormat=$initialFormat, initialFormatMetadata=$initialFormatMetadata, nameFormat=$nameFormat, nameFormatMetadata=$nameFormatMetadata, signDateFormat=$signDateFormat, signDateFormatMetadata=$signDateFormatMetadata, signTimeFormat=$signTimeFormat, signTimeFormatMetadata=$signTimeFormatMetadata, timeFormat=$timeFormat, timeFormatMetadata=$timeFormatMetadata, timeZone=$timeZone, timeZoneMetadata=$timeZoneMetadata]';

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (addressFormat != null) {
      _json[r'addressFormat'] = addressFormat;
    }
    if (addressFormatMetadata != null) {
      _json[r'addressFormatMetadata'] = addressFormatMetadata;
    }
    if (allowRegion != null) {
      _json[r'allowRegion'] = allowRegion;
    }
    if (calendarType != null) {
      _json[r'calendarType'] = calendarType;
    }
    if (calendarTypeMetadata != null) {
      _json[r'calendarTypeMetadata'] = calendarTypeMetadata;
    }
    if (cultureName != null) {
      _json[r'cultureName'] = cultureName;
    }
    if (cultureNameMetadata != null) {
      _json[r'cultureNameMetadata'] = cultureNameMetadata;
    }
    if (currencyCode != null) {
      _json[r'currencyCode'] = currencyCode;
    }
    if (currencyCodeMetadata != null) {
      _json[r'currencyCodeMetadata'] = currencyCodeMetadata;
    }
    if (currencyNegativeFormat != null) {
      _json[r'currencyNegativeFormat'] = currencyNegativeFormat;
    }
    if (currencyNegativeFormatMetadata != null) {
      _json[r'currencyNegativeFormatMetadata'] = currencyNegativeFormatMetadata;
    }
    if (currencyPositiveFormat != null) {
      _json[r'currencyPositiveFormat'] = currencyPositiveFormat;
    }
    if (currencyPositiveFormatMetadata != null) {
      _json[r'currencyPositiveFormatMetadata'] = currencyPositiveFormatMetadata;
    }
    if (customDateFormat != null) {
      _json[r'customDateFormat'] = customDateFormat;
    }
    if (customSignDateFormat != null) {
      _json[r'customSignDateFormat'] = customSignDateFormat;
    }
    if (customSignTimeFormat != null) {
      _json[r'customSignTimeFormat'] = customSignTimeFormat;
    }
    if (customTimeFormat != null) {
      _json[r'customTimeFormat'] = customTimeFormat;
    }
    if (dateFormat != null) {
      _json[r'dateFormat'] = dateFormat;
    }
    if (dateFormatMetadata != null) {
      _json[r'dateFormatMetadata'] = dateFormatMetadata;
    }
    if (effectiveAddressFormat != null) {
      _json[r'effectiveAddressFormat'] = effectiveAddressFormat;
    }
    if (effectiveCalendarType != null) {
      _json[r'effectiveCalendarType'] = effectiveCalendarType;
    }
    if (effectiveCurrencyCode != null) {
      _json[r'effectiveCurrencyCode'] = effectiveCurrencyCode;
    }
    if (effectiveCurrencyNegativeFormat != null) {
      _json[r'effectiveCurrencyNegativeFormat'] = effectiveCurrencyNegativeFormat;
    }
    if (effectiveCurrencyPositiveFormat != null) {
      _json[r'effectiveCurrencyPositiveFormat'] = effectiveCurrencyPositiveFormat;
    }
    if (effectiveCustomDateFormat != null) {
      _json[r'effectiveCustomDateFormat'] = effectiveCustomDateFormat;
    }
    if (effectiveCustomTimeFormat != null) {
      _json[r'effectiveCustomTimeFormat'] = effectiveCustomTimeFormat;
    }
    if (effectiveDateFormat != null) {
      _json[r'effectiveDateFormat'] = effectiveDateFormat;
    }
    if (effectiveInitialFormat != null) {
      _json[r'effectiveInitialFormat'] = effectiveInitialFormat;
    }
    if (effectiveNameFormat != null) {
      _json[r'effectiveNameFormat'] = effectiveNameFormat;
    }
    if (effectiveTimeFormat != null) {
      _json[r'effectiveTimeFormat'] = effectiveTimeFormat;
    }
    if (effectiveTimeZone != null) {
      _json[r'effectiveTimeZone'] = effectiveTimeZone;
    }
    if (initialFormat != null) {
      _json[r'initialFormat'] = initialFormat;
    }
    if (initialFormatMetadata != null) {
      _json[r'initialFormatMetadata'] = initialFormatMetadata;
    }
    if (nameFormat != null) {
      _json[r'nameFormat'] = nameFormat;
    }
    if (nameFormatMetadata != null) {
      _json[r'nameFormatMetadata'] = nameFormatMetadata;
    }
    if (signDateFormat != null) {
      _json[r'signDateFormat'] = signDateFormat;
    }
    if (signDateFormatMetadata != null) {
      _json[r'signDateFormatMetadata'] = signDateFormatMetadata;
    }
    if (signTimeFormat != null) {
      _json[r'signTimeFormat'] = signTimeFormat;
    }
    if (signTimeFormatMetadata != null) {
      _json[r'signTimeFormatMetadata'] = signTimeFormatMetadata;
    }
    if (timeFormat != null) {
      _json[r'timeFormat'] = timeFormat;
    }
    if (timeFormatMetadata != null) {
      _json[r'timeFormatMetadata'] = timeFormatMetadata;
    }
    if (timeZone != null) {
      _json[r'timeZone'] = timeZone;
    }
    if (timeZoneMetadata != null) {
      _json[r'timeZoneMetadata'] = timeZoneMetadata;
    }
    return _json;
  }

  /// Returns a new [LocalePolicy] instance and imports its values from
  /// [value] if it's a [Map], null otherwise.
  // ignore: prefer_constructors_over_static_methods
  static LocalePolicy? fromJson(dynamic value) {
    if (value is Map) {
      final json = value.cast<String, dynamic>();

      // Ensure that the map contains the required keys.
      // Note 1: the values aren't checked for validity beyond being non-null.
      // Note 2: this code is stripped in release mode!
      assert(() {
        requiredKeys.forEach((key) {
          assert(json.containsKey(key), 'Required key "LocalePolicy[$key]" is missing from JSON.');
          assert(json[key] != null, 'Required key "LocalePolicy[$key]" has a null value in JSON.');
        });
        return true;
      }());

      return LocalePolicy(
        addressFormat: mapValueOfType<String>(json, r'addressFormat'),
        addressFormatMetadata: SettingsMetadata.fromJson(json[r'addressFormatMetadata']),
        allowRegion: mapValueOfType<String>(json, r'allowRegion'),
        calendarType: mapValueOfType<String>(json, r'calendarType'),
        calendarTypeMetadata: SettingsMetadata.fromJson(json[r'calendarTypeMetadata']),
        cultureName: mapValueOfType<String>(json, r'cultureName'),
        cultureNameMetadata: SettingsMetadata.fromJson(json[r'cultureNameMetadata']),
        currencyCode: mapValueOfType<String>(json, r'currencyCode'),
        currencyCodeMetadata: SettingsMetadata.fromJson(json[r'currencyCodeMetadata']),
        currencyNegativeFormat: mapValueOfType<String>(json, r'currencyNegativeFormat'),
        currencyNegativeFormatMetadata: SettingsMetadata.fromJson(json[r'currencyNegativeFormatMetadata']),
        currencyPositiveFormat: mapValueOfType<String>(json, r'currencyPositiveFormat'),
        currencyPositiveFormatMetadata: SettingsMetadata.fromJson(json[r'currencyPositiveFormatMetadata']),
        customDateFormat: mapValueOfType<String>(json, r'customDateFormat'),
        customSignDateFormat: mapValueOfType<String>(json, r'customSignDateFormat'),
        customSignTimeFormat: mapValueOfType<String>(json, r'customSignTimeFormat'),
        customTimeFormat: mapValueOfType<String>(json, r'customTimeFormat'),
        dateFormat: mapValueOfType<String>(json, r'dateFormat'),
        dateFormatMetadata: SettingsMetadata.fromJson(json[r'dateFormatMetadata']),
        effectiveAddressFormat: mapValueOfType<String>(json, r'effectiveAddressFormat'),
        effectiveCalendarType: mapValueOfType<String>(json, r'effectiveCalendarType'),
        effectiveCurrencyCode: mapValueOfType<String>(json, r'effectiveCurrencyCode'),
        effectiveCurrencyNegativeFormat: mapValueOfType<String>(json, r'effectiveCurrencyNegativeFormat'),
        effectiveCurrencyPositiveFormat: mapValueOfType<String>(json, r'effectiveCurrencyPositiveFormat'),
        effectiveCustomDateFormat: mapValueOfType<String>(json, r'effectiveCustomDateFormat'),
        effectiveCustomTimeFormat: mapValueOfType<String>(json, r'effectiveCustomTimeFormat'),
        effectiveDateFormat: mapValueOfType<String>(json, r'effectiveDateFormat'),
        effectiveInitialFormat: mapValueOfType<String>(json, r'effectiveInitialFormat'),
        effectiveNameFormat: mapValueOfType<String>(json, r'effectiveNameFormat'),
        effectiveTimeFormat: mapValueOfType<String>(json, r'effectiveTimeFormat'),
        effectiveTimeZone: mapValueOfType<String>(json, r'effectiveTimeZone'),
        initialFormat: mapValueOfType<String>(json, r'initialFormat'),
        initialFormatMetadata: SettingsMetadata.fromJson(json[r'initialFormatMetadata']),
        nameFormat: mapValueOfType<String>(json, r'nameFormat'),
        nameFormatMetadata: SettingsMetadata.fromJson(json[r'nameFormatMetadata']),
        signDateFormat: mapValueOfType<String>(json, r'signDateFormat'),
        signDateFormatMetadata: SettingsMetadata.fromJson(json[r'signDateFormatMetadata']),
        signTimeFormat: mapValueOfType<String>(json, r'signTimeFormat'),
        signTimeFormatMetadata: SettingsMetadata.fromJson(json[r'signTimeFormatMetadata']),
        timeFormat: mapValueOfType<String>(json, r'timeFormat'),
        timeFormatMetadata: SettingsMetadata.fromJson(json[r'timeFormatMetadata']),
        timeZone: mapValueOfType<String>(json, r'timeZone'),
        timeZoneMetadata: SettingsMetadata.fromJson(json[r'timeZoneMetadata']),
      );
    }
    return null;
  }

  static List<LocalePolicy>? listFromJson(dynamic json, {bool growable = false,}) {
    final result = <LocalePolicy>[];
    if (json is List && json.isNotEmpty) {
      for (final row in json) {
        final value = LocalePolicy.fromJson(row);
        if (value != null) {
          result.add(value);
        }
      }
    }
    return result.toList(growable: growable);
  }

  static Map<String, LocalePolicy> mapFromJson(dynamic json) {
    final map = <String, LocalePolicy>{};
    if (json is Map && json.isNotEmpty) {
      json = json.cast<String, dynamic>(); // ignore: parameter_assignments
      for (final entry in json.entries) {
        final value = LocalePolicy.fromJson(entry.value);
        if (value != null) {
          map[entry.key] = value;
        }
      }
    }
    return map;
  }

  // maps a json object with a list of LocalePolicy-objects as value to a dart map
  static Map<String, List<LocalePolicy>> mapListFromJson(dynamic json, {bool growable = false,}) {
    final map = <String, List<LocalePolicy>>{};
    if (json is Map && json.isNotEmpty) {
      json = json.cast<String, dynamic>(); // ignore: parameter_assignments
      for (final entry in json.entries) {
        final value = LocalePolicy.listFromJson(entry.value, growable: growable,);
        if (value != null) {
          map[entry.key] = value;
        }
      }
    }
    return map;
  }

  /// The list of required keys that must be present in a JSON.
  static const requiredKeys = <String>{
  };
}


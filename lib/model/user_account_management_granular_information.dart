// Copyright 2022 Giammarco Boscaro. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

//
// AUTO-GENERATED FILE, DO NOT MODIFY!
//
// @dart=2.17

// ignore_for_file: unused_element, unused_import
// ignore_for_file: always_put_required_named_parameters_first
// ignore_for_file: constant_identifier_names
// ignore_for_file: lines_longer_than_80_chars

part of it.docusign.sdk.esignature;

class UserAccountManagementGranularInformation {
  /// Returns a new [UserAccountManagementGranularInformation] instance.
  UserAccountManagementGranularInformation({
    this.canManageAccountSecuritySettings,
    this.canManageAccountSecuritySettingsMetadata,
    this.canManageAccountSettings,
    this.canManageAccountSettingsMetadata,
    this.canManageAdmins,
    this.canManageAdminsMetadata,
    this.canManageConnect,
    this.canManageConnectMetadata,
    this.canManageDocumentRetention,
    this.canManageDocumentRetentionMetadata,
    this.canManageEnvelopeTransfer,
    this.canManageEnvelopeTransferMetadata,
    this.canManageGroupsButNotUsers,
    this.canManageGroupsButNotUsersMetadata,
    this.canManageReporting,
    this.canManageReportingMetadata,
    this.canManageSharing,
    this.canManageSharingMetadata,
    this.canManageSigningGroups,
    this.canManageSigningGroupsMetadata,
    this.canManageStamps,
    this.canManageStampsMetadata,
    this.canManageUsers,
    this.canManageUsersMetadata,
    this.canViewUsers,
  });

  /// **True** if the user can manage account security settings.
  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  String? canManageAccountSecuritySettings;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  SettingsMetadata? canManageAccountSecuritySettingsMetadata;

  /// **True** if the user can manage account settings.
  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  String? canManageAccountSettings;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  SettingsMetadata? canManageAccountSettingsMetadata;

  /// **True** if the user can manage administrators.
  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  String? canManageAdmins;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  SettingsMetadata? canManageAdminsMetadata;

  /// 
  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  String? canManageConnect;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  SettingsMetadata? canManageConnectMetadata;

  /// 
  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  String? canManageDocumentRetention;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  SettingsMetadata? canManageDocumentRetentionMetadata;

  /// 
  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  String? canManageEnvelopeTransfer;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  SettingsMetadata? canManageEnvelopeTransferMetadata;

  /// 
  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  String? canManageGroupsButNotUsers;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  SettingsMetadata? canManageGroupsButNotUsersMetadata;

  /// **True** if the user can manage reporting.
  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  String? canManageReporting;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  SettingsMetadata? canManageReportingMetadata;

  /// **True** if the user can manage sharing.
  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  String? canManageSharing;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  SettingsMetadata? canManageSharingMetadata;

  /// **True** if the user can manage signing groups.
  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  String? canManageSigningGroups;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  SettingsMetadata? canManageSigningGroupsMetadata;

  /// 
  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  String? canManageStamps;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  SettingsMetadata? canManageStampsMetadata;

  /// **True** if the user can manage users.
  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  String? canManageUsers;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  SettingsMetadata? canManageUsersMetadata;

  /// 
  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  String? canViewUsers;

  @override
  bool operator ==(Object other) => identical(this, other) || other is UserAccountManagementGranularInformation &&
     other.canManageAccountSecuritySettings == canManageAccountSecuritySettings &&
     other.canManageAccountSecuritySettingsMetadata == canManageAccountSecuritySettingsMetadata &&
     other.canManageAccountSettings == canManageAccountSettings &&
     other.canManageAccountSettingsMetadata == canManageAccountSettingsMetadata &&
     other.canManageAdmins == canManageAdmins &&
     other.canManageAdminsMetadata == canManageAdminsMetadata &&
     other.canManageConnect == canManageConnect &&
     other.canManageConnectMetadata == canManageConnectMetadata &&
     other.canManageDocumentRetention == canManageDocumentRetention &&
     other.canManageDocumentRetentionMetadata == canManageDocumentRetentionMetadata &&
     other.canManageEnvelopeTransfer == canManageEnvelopeTransfer &&
     other.canManageEnvelopeTransferMetadata == canManageEnvelopeTransferMetadata &&
     other.canManageGroupsButNotUsers == canManageGroupsButNotUsers &&
     other.canManageGroupsButNotUsersMetadata == canManageGroupsButNotUsersMetadata &&
     other.canManageReporting == canManageReporting &&
     other.canManageReportingMetadata == canManageReportingMetadata &&
     other.canManageSharing == canManageSharing &&
     other.canManageSharingMetadata == canManageSharingMetadata &&
     other.canManageSigningGroups == canManageSigningGroups &&
     other.canManageSigningGroupsMetadata == canManageSigningGroupsMetadata &&
     other.canManageStamps == canManageStamps &&
     other.canManageStampsMetadata == canManageStampsMetadata &&
     other.canManageUsers == canManageUsers &&
     other.canManageUsersMetadata == canManageUsersMetadata &&
     other.canViewUsers == canViewUsers;

  @override
  int get hashCode =>
    // ignore: unnecessary_parenthesis
    (canManageAccountSecuritySettings == null ? 0 : canManageAccountSecuritySettings!.hashCode) +
    (canManageAccountSecuritySettingsMetadata == null ? 0 : canManageAccountSecuritySettingsMetadata!.hashCode) +
    (canManageAccountSettings == null ? 0 : canManageAccountSettings!.hashCode) +
    (canManageAccountSettingsMetadata == null ? 0 : canManageAccountSettingsMetadata!.hashCode) +
    (canManageAdmins == null ? 0 : canManageAdmins!.hashCode) +
    (canManageAdminsMetadata == null ? 0 : canManageAdminsMetadata!.hashCode) +
    (canManageConnect == null ? 0 : canManageConnect!.hashCode) +
    (canManageConnectMetadata == null ? 0 : canManageConnectMetadata!.hashCode) +
    (canManageDocumentRetention == null ? 0 : canManageDocumentRetention!.hashCode) +
    (canManageDocumentRetentionMetadata == null ? 0 : canManageDocumentRetentionMetadata!.hashCode) +
    (canManageEnvelopeTransfer == null ? 0 : canManageEnvelopeTransfer!.hashCode) +
    (canManageEnvelopeTransferMetadata == null ? 0 : canManageEnvelopeTransferMetadata!.hashCode) +
    (canManageGroupsButNotUsers == null ? 0 : canManageGroupsButNotUsers!.hashCode) +
    (canManageGroupsButNotUsersMetadata == null ? 0 : canManageGroupsButNotUsersMetadata!.hashCode) +
    (canManageReporting == null ? 0 : canManageReporting!.hashCode) +
    (canManageReportingMetadata == null ? 0 : canManageReportingMetadata!.hashCode) +
    (canManageSharing == null ? 0 : canManageSharing!.hashCode) +
    (canManageSharingMetadata == null ? 0 : canManageSharingMetadata!.hashCode) +
    (canManageSigningGroups == null ? 0 : canManageSigningGroups!.hashCode) +
    (canManageSigningGroupsMetadata == null ? 0 : canManageSigningGroupsMetadata!.hashCode) +
    (canManageStamps == null ? 0 : canManageStamps!.hashCode) +
    (canManageStampsMetadata == null ? 0 : canManageStampsMetadata!.hashCode) +
    (canManageUsers == null ? 0 : canManageUsers!.hashCode) +
    (canManageUsersMetadata == null ? 0 : canManageUsersMetadata!.hashCode) +
    (canViewUsers == null ? 0 : canViewUsers!.hashCode);

  @override
  String toString() => 'UserAccountManagementGranularInformation[canManageAccountSecuritySettings=$canManageAccountSecuritySettings, canManageAccountSecuritySettingsMetadata=$canManageAccountSecuritySettingsMetadata, canManageAccountSettings=$canManageAccountSettings, canManageAccountSettingsMetadata=$canManageAccountSettingsMetadata, canManageAdmins=$canManageAdmins, canManageAdminsMetadata=$canManageAdminsMetadata, canManageConnect=$canManageConnect, canManageConnectMetadata=$canManageConnectMetadata, canManageDocumentRetention=$canManageDocumentRetention, canManageDocumentRetentionMetadata=$canManageDocumentRetentionMetadata, canManageEnvelopeTransfer=$canManageEnvelopeTransfer, canManageEnvelopeTransferMetadata=$canManageEnvelopeTransferMetadata, canManageGroupsButNotUsers=$canManageGroupsButNotUsers, canManageGroupsButNotUsersMetadata=$canManageGroupsButNotUsersMetadata, canManageReporting=$canManageReporting, canManageReportingMetadata=$canManageReportingMetadata, canManageSharing=$canManageSharing, canManageSharingMetadata=$canManageSharingMetadata, canManageSigningGroups=$canManageSigningGroups, canManageSigningGroupsMetadata=$canManageSigningGroupsMetadata, canManageStamps=$canManageStamps, canManageStampsMetadata=$canManageStampsMetadata, canManageUsers=$canManageUsers, canManageUsersMetadata=$canManageUsersMetadata, canViewUsers=$canViewUsers]';

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (canManageAccountSecuritySettings != null) {
      _json[r'canManageAccountSecuritySettings'] = canManageAccountSecuritySettings;
    }
    if (canManageAccountSecuritySettingsMetadata != null) {
      _json[r'canManageAccountSecuritySettingsMetadata'] = canManageAccountSecuritySettingsMetadata;
    }
    if (canManageAccountSettings != null) {
      _json[r'canManageAccountSettings'] = canManageAccountSettings;
    }
    if (canManageAccountSettingsMetadata != null) {
      _json[r'canManageAccountSettingsMetadata'] = canManageAccountSettingsMetadata;
    }
    if (canManageAdmins != null) {
      _json[r'canManageAdmins'] = canManageAdmins;
    }
    if (canManageAdminsMetadata != null) {
      _json[r'canManageAdminsMetadata'] = canManageAdminsMetadata;
    }
    if (canManageConnect != null) {
      _json[r'canManageConnect'] = canManageConnect;
    }
    if (canManageConnectMetadata != null) {
      _json[r'canManageConnectMetadata'] = canManageConnectMetadata;
    }
    if (canManageDocumentRetention != null) {
      _json[r'canManageDocumentRetention'] = canManageDocumentRetention;
    }
    if (canManageDocumentRetentionMetadata != null) {
      _json[r'canManageDocumentRetentionMetadata'] = canManageDocumentRetentionMetadata;
    }
    if (canManageEnvelopeTransfer != null) {
      _json[r'canManageEnvelopeTransfer'] = canManageEnvelopeTransfer;
    }
    if (canManageEnvelopeTransferMetadata != null) {
      _json[r'canManageEnvelopeTransferMetadata'] = canManageEnvelopeTransferMetadata;
    }
    if (canManageGroupsButNotUsers != null) {
      _json[r'canManageGroupsButNotUsers'] = canManageGroupsButNotUsers;
    }
    if (canManageGroupsButNotUsersMetadata != null) {
      _json[r'canManageGroupsButNotUsersMetadata'] = canManageGroupsButNotUsersMetadata;
    }
    if (canManageReporting != null) {
      _json[r'canManageReporting'] = canManageReporting;
    }
    if (canManageReportingMetadata != null) {
      _json[r'canManageReportingMetadata'] = canManageReportingMetadata;
    }
    if (canManageSharing != null) {
      _json[r'canManageSharing'] = canManageSharing;
    }
    if (canManageSharingMetadata != null) {
      _json[r'canManageSharingMetadata'] = canManageSharingMetadata;
    }
    if (canManageSigningGroups != null) {
      _json[r'canManageSigningGroups'] = canManageSigningGroups;
    }
    if (canManageSigningGroupsMetadata != null) {
      _json[r'canManageSigningGroupsMetadata'] = canManageSigningGroupsMetadata;
    }
    if (canManageStamps != null) {
      _json[r'canManageStamps'] = canManageStamps;
    }
    if (canManageStampsMetadata != null) {
      _json[r'canManageStampsMetadata'] = canManageStampsMetadata;
    }
    if (canManageUsers != null) {
      _json[r'canManageUsers'] = canManageUsers;
    }
    if (canManageUsersMetadata != null) {
      _json[r'canManageUsersMetadata'] = canManageUsersMetadata;
    }
    if (canViewUsers != null) {
      _json[r'canViewUsers'] = canViewUsers;
    }
    return _json;
  }

  /// Returns a new [UserAccountManagementGranularInformation] instance and imports its values from
  /// [value] if it's a [Map], null otherwise.
  // ignore: prefer_constructors_over_static_methods
  static UserAccountManagementGranularInformation? fromJson(dynamic value) {
    if (value is Map) {
      final json = value.cast<String, dynamic>();

      // Ensure that the map contains the required keys.
      // Note 1: the values aren't checked for validity beyond being non-null.
      // Note 2: this code is stripped in release mode!
      assert(() {
        requiredKeys.forEach((key) {
          assert(json.containsKey(key), 'Required key "UserAccountManagementGranularInformation[$key]" is missing from JSON.');
          assert(json[key] != null, 'Required key "UserAccountManagementGranularInformation[$key]" has a null value in JSON.');
        });
        return true;
      }());

      return UserAccountManagementGranularInformation(
        canManageAccountSecuritySettings: mapValueOfType<String>(json, r'canManageAccountSecuritySettings'),
        canManageAccountSecuritySettingsMetadata: SettingsMetadata.fromJson(json[r'canManageAccountSecuritySettingsMetadata']),
        canManageAccountSettings: mapValueOfType<String>(json, r'canManageAccountSettings'),
        canManageAccountSettingsMetadata: SettingsMetadata.fromJson(json[r'canManageAccountSettingsMetadata']),
        canManageAdmins: mapValueOfType<String>(json, r'canManageAdmins'),
        canManageAdminsMetadata: SettingsMetadata.fromJson(json[r'canManageAdminsMetadata']),
        canManageConnect: mapValueOfType<String>(json, r'canManageConnect'),
        canManageConnectMetadata: SettingsMetadata.fromJson(json[r'canManageConnectMetadata']),
        canManageDocumentRetention: mapValueOfType<String>(json, r'canManageDocumentRetention'),
        canManageDocumentRetentionMetadata: SettingsMetadata.fromJson(json[r'canManageDocumentRetentionMetadata']),
        canManageEnvelopeTransfer: mapValueOfType<String>(json, r'canManageEnvelopeTransfer'),
        canManageEnvelopeTransferMetadata: SettingsMetadata.fromJson(json[r'canManageEnvelopeTransferMetadata']),
        canManageGroupsButNotUsers: mapValueOfType<String>(json, r'canManageGroupsButNotUsers'),
        canManageGroupsButNotUsersMetadata: SettingsMetadata.fromJson(json[r'canManageGroupsButNotUsersMetadata']),
        canManageReporting: mapValueOfType<String>(json, r'canManageReporting'),
        canManageReportingMetadata: SettingsMetadata.fromJson(json[r'canManageReportingMetadata']),
        canManageSharing: mapValueOfType<String>(json, r'canManageSharing'),
        canManageSharingMetadata: SettingsMetadata.fromJson(json[r'canManageSharingMetadata']),
        canManageSigningGroups: mapValueOfType<String>(json, r'canManageSigningGroups'),
        canManageSigningGroupsMetadata: SettingsMetadata.fromJson(json[r'canManageSigningGroupsMetadata']),
        canManageStamps: mapValueOfType<String>(json, r'canManageStamps'),
        canManageStampsMetadata: SettingsMetadata.fromJson(json[r'canManageStampsMetadata']),
        canManageUsers: mapValueOfType<String>(json, r'canManageUsers'),
        canManageUsersMetadata: SettingsMetadata.fromJson(json[r'canManageUsersMetadata']),
        canViewUsers: mapValueOfType<String>(json, r'canViewUsers'),
      );
    }
    return null;
  }

  static List<UserAccountManagementGranularInformation>? listFromJson(dynamic json, {bool growable = false,}) {
    final result = <UserAccountManagementGranularInformation>[];
    if (json is List && json.isNotEmpty) {
      for (final row in json) {
        final value = UserAccountManagementGranularInformation.fromJson(row);
        if (value != null) {
          result.add(value);
        }
      }
    }
    return result.toList(growable: growable);
  }

  static Map<String, UserAccountManagementGranularInformation> mapFromJson(dynamic json) {
    final map = <String, UserAccountManagementGranularInformation>{};
    if (json is Map && json.isNotEmpty) {
      json = json.cast<String, dynamic>(); // ignore: parameter_assignments
      for (final entry in json.entries) {
        final value = UserAccountManagementGranularInformation.fromJson(entry.value);
        if (value != null) {
          map[entry.key] = value;
        }
      }
    }
    return map;
  }

  // maps a json object with a list of UserAccountManagementGranularInformation-objects as value to a dart map
  static Map<String, List<UserAccountManagementGranularInformation>> mapListFromJson(dynamic json, {bool growable = false,}) {
    final map = <String, List<UserAccountManagementGranularInformation>>{};
    if (json is Map && json.isNotEmpty) {
      json = json.cast<String, dynamic>(); // ignore: parameter_assignments
      for (final entry in json.entries) {
        final value = UserAccountManagementGranularInformation.listFromJson(entry.value, growable: growable,);
        if (value != null) {
          map[entry.key] = value;
        }
      }
    }
    return map;
  }

  /// The list of required keys that must be present in a JSON.
  static const requiredKeys = <String>{
  };
}

